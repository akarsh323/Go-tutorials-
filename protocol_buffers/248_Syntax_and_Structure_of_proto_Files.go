package main

import (
	"encoding/json"
	"fmt"
	"strings"
)

// protobuf_tutorial.go
// A cleaned-up, beginner-friendly walkthrough of Protocol Buffers (protobuf)
// and a short, runnable Go demo that compares JSON size to a simulated
// protobuf size.
//
// Goals:
//  - Explain the .proto "blueprint" clearly
//  - Show why protobuf is smaller than JSON (conceptually + simple demo)
//  - Remind important compatibility / tagging rules
//
// Note: This file DOES NOT require the protobuf compiler (protoc) to run.
// It's a teaching/demo file. In real projects you write a .proto file and
// run protoc to generate Go structs and marshalling code.

// Person is a Go struct used only for the demo. In real protobuf usage,
// this struct would be generated by protoc and include protobuf-specific
// tags and helpers.
type Person struct {
	Name         string   `json:"name"`
	ID           int32    `json:"id"`
	Email        string   `json:"email"`
	PhoneNumbers []string `json:"phone_numbers"`
}

func main() {
	printHeader("Protocol Buffers (Protobuf) — Quick Guide")

	printSection("1) What is Protobuf (short)")
	fmt.Println(strings.TrimSpace(`
Protobuf is a compact binary serialization format with an explicit schema.
- Schema first: you write a .proto file that declares messages and field numbers.
- Efficiency: the wire format uses numeric tags (small integers) and compact
  encodings (varints) which makes it much smaller than equivalent JSON.
- Use cases: gRPC, internal microservices, mobile apps where bandwidth matters.
	`))

	example1ProtoSyntax()
	example2SizeComparison()
	example3SyntaxRules()

	printFooter("End of demo — want a .proto example file or a go:generate snippet?")
}

// ---------------------------------------------------------
// SECTION 1: The .proto "Blueprint" (printed as a string)
// ---------------------------------------------------------
func example1ProtoSyntax() {
	printSection("Example: What a .proto file looks like")

	proto := `syntax = "proto3";

package social;

// A simple Person message.
message Person {
  string name = 1;             // tag 1
  int32 id = 2;                // tag 2
  string email = 3;            // tag 3
  repeated string phone_numbers = 4; // repeated = list/slice
}
`

	fmt.Println("This is the content of a typical 'person.proto' file:\n")
	fmt.Println(proto)

	fmt.Println("Notes:")
	fmt.Println("  - Use proto3 unless you have a specific reason to use proto2.")
	fmt.Println("  - Field numbers (tags) are what get encoded on the wire.")
	fmt.Println("  - Changing a field's tag number is breaking — don't rename tags.")
}

// ---------------------------------------------------------
// SECTION 2: A tiny, runnable size-comparison demo
// ---------------------------------------------------------
func example2SizeComparison() {
	printSection("Size comparison: JSON vs. (simulated) Protobuf")

	p := Person{
		Name:         "Alice",
		ID:           150,
		Email:        "alice@example.com",
		PhoneNumbers: []string{"555-0100", "555-0101"},
	}

	// JSON serialization (real)
	jsonBytes, err := json.Marshal(p)
	if err != nil {
		fmt.Println("error marshaling JSON:", err)
		return
	}

	fmt.Printf("JSON Payload: %s\n", jsonBytes)
	fmt.Printf("JSON Size:    %d bytes\n", len(jsonBytes))

	// Simulated protobuf size: we cannot produce a real protobuf without
	// running 'protoc' or importing generated code. But we can illustrate
	// why protobuf is smaller:
	//  - Field names are not sent, only small numeric tags.
	//  - Integers use variable-length encoding (varint) which can be 1-5 bytes.
	// For a gentle teaching estimate we assume protobuf is roughly half the
	// JSON size here. This is an approximation used only for explanation.
	estimatedProtoSize := len(jsonBytes) / 2
	fmt.Printf("\nProto Payload (simulated hex): 08 05 41 6c 69 63 65 10 96 01 ...\n")
	fmt.Printf("Proto Size (estimated): ~%d bytes\n", estimatedProtoSize)

	savings := float64(len(jsonBytes)-estimatedProtoSize) / float64(len(jsonBytes)) * 100
	fmt.Printf("Bandwidth savings (approx): ~%.0f%%\n", savings)

	fmt.Println("\nTakeaway: Protobuf avoids repeating field names and uses compact encodings.")
}

// ---------------------------------------------------------
// SECTION 3: Important syntax & compatibility rules (recap)
// ---------------------------------------------------------
func example3SyntaxRules() {
	printSection("Syntax rules & best practices — quick recap")

	fmt.Println("1) Tag numbers:")
	fmt.Println("   - Tags must be unique within a message.")
	fmt.Println("   - Tags 1-15 encode to a single byte on the wire — use these for common fields.")
	fmt.Println("   - Avoid using tag numbers in the reserved ranges if your proto style forbids them.")

	fmt.Println("\n2) Naming:")
	fmt.Println("   - Message names: PascalCase. field_names: snake_case.")

	fmt.Println("\n3) Compatibility:")
	fmt.Println("   - You can add new fields (old code ignores unknown tags).")
	fmt.Println("   - NEVER change an existing field's tag number — that breaks compatibility.")
	fmt.Println("   - You can remove fields but it's safer to mark them 'reserved' so the tag numbers aren't reused.")
}

// ---------------------
// Helper printing funcs
// ---------------------
func printHeader(title string) {
	fmt.Println("═══════════════════════════════════════════════════════════")
	fmt.Println(title)
	fmt.Println("═══════════════════════════════════════════════════════════\n")
}

func printSection(title string) {
	fmt.Println("---", title, "---")
}

func printFooter(msg string) {
	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Println(msg)
}
